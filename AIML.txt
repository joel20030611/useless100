PRACTICAL NO: 01 - Breadth First Search (BFS)
from collections import deque
def bfs(graph,start):
    visited=set()
    queue=deque([start])
    visited.add(start)
    while queue:
        node=queue.popleft()
        print(node,end='')
        for neighbor in graph[node]:
            if neighbor not in visited:
                queue.append(neighbor)
                visited.add(neighbor)

graph={
    'A':['B','C'],
    'B':['D','E'],
    'C':['F'],
    'D':[],
    'E':['F'],
    'F':[]
    }
print("BFS traversal starting from nod 'A':")
bfs(graph, 'A')


PRACTICAL NO: 02 - Depth First Search (DFS)
from collections import deque
def dfs(graph,start,visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    print(start,end='')
    for neighbor in graph[start]:
        if neighbor not in visited:
            dfs(graph,neighbor,visited)

graph={
    'A':['B','C'],
    'B':['D','E'],
    'C':['F'],
    'D':[],
    'E':['F'],
    'F':[]
    }
print("DFS traversal starting from nod 'A':")
dfs(graph, 'A')

PRACTICAL NO: 03 - Write a program to implemented depth limited serach for given graph.

def dls_trace(node,goal,depth,graph,trace,found_flag):
    if found_flag[0]:
        return
    trace.append(node)
    if node==goal:
        found_flag[0]=True
        return
    if depth==0:
        return
    for neighbour in graph.get(node, []):
        dls_trace(neighbour,goal,depth-1,graph,trace,found_flag)

graph={
    'A':['B','C'],
    'B':['D','E'],
    'D':['G','H'],
    'E':['I'],
    'G':[],
    'C':['F','J'],
    'F':[],
    'H':[],
    'I':[],
    'J':[]
    }


PRACTICAL NO: 04 -Write a program implemented depth limited serach for given graph.(Idds) 

def dls_trace(node,goal,depth,graph,visited,trace):
    visited.add(node)
    trace.append(node)
    if depth==0:
        return node==goal

    for neighbor in graph.get(node, []):
        if neighbor not in visited :
            if dls_trace(neighbor,goal,depth-1,graph,visited,trace):
                return True
    
    return False

def iddfs(start,goal,max_depth,graph):
    for depth in range(max_depth+1):
        visited=set()
        trace=[]
        dls_trace(start,goal,depth,graph,visited,trace)
        print(f"Iteration {depth}:"+"->".join(trace))
        if goal in trace :
            return True
            
    print("No path foud")
    return False

PRACTICAL NO: 05 - Truth Table

import itertools
def truth_table(formula, variables):
    print("|".join(variables)+"|"+formula)
    print("-"*(4*len(variables)+len(formula)+3))
    for vals in itertools.product([False,True],repeat=len(variables)):
        scope = dict(zip(variables,vals))
        result = eval(formula, {},scope)
        print("|".join(str(int(scope[v])) for v in variables)+"|"+str(int(result)))

truth_table("(P and Q)or(not P)",["P","Q"])
print("------------------------------------------")
truth_table("((not P)or Q) and (P and Q)",["P","Q"])

PRACTICAL NO: 06 - Well Formed Formula (WFF)

def is_wff(formula):
    ops,vars,='^','V','->','~',{chr(i) for i in range(65,91)}
    formula = formula.replace(" ","")
    stack,prev=[],None
    
    for ch in formula:
        if ch == '(': stack.append(ch)
        elif ch==')':
            if not stack: return False
            stack.pop()
        elif ch not in ops and ch not in vars: return False
        
        if ch in vars and (prev in vars or prev == ')'): return False
        if ch in ops-{'~'} and (prev in ops or prev in {'(',None}): return False
        if ch=='~' and (prev in vars or prev==')'): return False
        if ch==')' and (prev in ops or prev in {'(',None}): return False
        prev=ch
    return not stack

test_formulas = ["(P^Q)","~P","(PV(Q^R))","(P^)", "P Q", "(P->Q)", "((P^Q))", "->Q"]
for f in test_formulas:
    print(f,":","Well-formed" if is_wff(f) else "Not well-formed")

PRACTICAL NO: 07 - Alpha Beta Pruning

def ab(depth,idx,maxP,vals,a,b):
    if depth == 3:
        return vals[idx]
    if maxP:
        for i in range(2):
            a=max(a,ab(depth+1,idx*2+i,0,vals,a,b))
            if b<=a:
                break
        return a
    else:
        for i in range(2):
            b=min(b,ab(depth+1,idx*2+i+1,vals,a,b))
            if b<=a:
                break
        return b

vals=[2,3,5,9,0,1,7,5]
print("Optimal",ab(0,0,1,vals,float('-inf'),float('inf')))

PRACTICAL NO: 08 - Uniform Cost Search (UCS)

import heapq
def uniform_cost_search(graph,start,goal):
    queue=[(0,[start])] #cost,path
    visited=set()
    expanded_steps=[] #[To store expamnion order
    while queue:
        cost,path=heapq.heappop(queue)
        node=path[-1]
        expanded_steps.append((node,cost,[p for _,p in queue]))

        if node == goal:
            return path,cost,expanded_steps
        
        if node not in visited:
            visited.add(node)
            for neighbor,edge_cost in graph.get(node,[]):
                if neighbor not in visited:
                    heapq.heappush(queue, (cost+edge_cost,path+[neighbor]))

    return None,float("inf"), expanded_steps

#Grpah from image (adjacency List)
graph={
    'S':[('A',3),('B',2),('C',7)],
    'A':[('D',3),('E',8),('G',15)],
    'B':[('G',20)],
    'C':[('G',6)],
    'D':[],
    'E':['F'],
    'G':[]
}

start_node='S'
goal_node='G'
path,total_cost,steps=uniform_cost_search(graph,start_node,goal_node)
#print results
print("Uniform cost search steps:")
for step in steps:
    node,cost,frontier=step
    print(f"Expanded Node:{node},Path Cost:{cost},Frontier:{frontier}")
print("\nSolution Path Found:", "->".join(path))
print("Total Cost:",total_cost)
print("Number of Nodes Expanded (including goal):",len(steps))

PRACTICAL NO: 09 - A* Algorithm

def aostar(node,graph,h,solved):
    if node in solved:
        return
    
    min_cost,best_children=float('inf'),[]

    for option in graph.get(node,[]):
        option_cost=sum(h[child]+weight for child,weight in option)
        children=[child for child,_ in option]
        
        if option_cost<min_cost:
            min_cost,best_children=option_cost,children
    h[node]=min_cost
    if all(c in solved for c in best_children):
        solved.add(node)
        for c in best_children:
            aostar(c,graph,h,solved)

#example
h={'A':1, 'B':3, 'C':2, 'D':10, 'E':4, 'G':2, 'H':7, 'I':1, 'J':1, 'F':4}
graph={
    'A':[[('B',1),('C',1)],[('D',1)]],
    'B':[[('G',1)],[('H',1)]],
    'C':[[('J',1)]],
    'D':[[('E',1)],[('F',1)]],
    'G':[[('I',1)]]
}

solved=set()
aostar('A',graph,h,solved)
print("Final Heuristic Values",h)
print("Values of A:",h['A'])

PRACTICAL NO: 10 - K-Nearest Neighbors (KNN)

from sklearn.neighbors import KNeighborsClassifier
data_points=[(2,10),(2,6),(11,11),(6,9),(6,5),(1,2),(5,10),(4,9),(10,12),(7,5)]
class_labels=["C2","C1","C3","C2","C1","C2","C2","C3","C3","C1"]
untrained_model=KNeighborsClassifier(n_neighbors=3,metric="euclidean")
trained_model=untrained_model.fit(data_points,class_labels)
predicted_class=trained_model.predict([ (5,7) ])
print("The data points are:")
print(data_points)
print("The class labels are:")
print(class_labels)
print("Predicated class label for (5,7) is:")
print(predicted_class)